{"file_contents":{"index.js":{"content":"// index.js (Replit-ready, with CORS + node-fetch v2)\nconst express = require(\"express\");\nconst cors = require(\"cors\");\nconst fetch = (...args) => import(\"node-fetch\").then(({default: fetch}) => fetch(...args));\nconst app = express();\n\n// Constants\nconst DEFAULT_VOICE = \"21m00Tcm4TlvDq8ikWAM\";\nconst DEFAULT_MODEL = \"eleven_multilingual_v2\";\n\n// Simple in-memory cache\nconst cache = new Map();\nfunction cacheKey(payload) {\n  return JSON.stringify(payload);\n}\nfunction cacheGet(key) {\n  return cache.get(key);\n}\nfunction cacheSet(key, value) {\n  cache.set(key, value);\n}\nconst PORT = process.env.PORT || 5000;\n\n// --- CORS (keep) ---\napp.use(cors()); // allow all origins\n\napp.get(\"/\", (_req, res) => res.send(\"TTS server is running!\"));\n\n// small helper that serves a Buffer as MP3 with Range support\nfunction sendMp3Buffer(req, res, mp3Buffer, filename = 'tts.mp3') {\n  res.setHeader('Accept-Ranges', 'bytes');\n\n  const range = req.headers.range;\n  const size = mp3Buffer.length;\n\n  if (range) {\n    // bytes=start-end\n    const [startStr, endStr] = range.replace(/bytes=/, '').split('-');\n    const start = parseInt(startStr, 10);\n    const end = endStr ? parseInt(endStr, 10) : size - 1;\n\n    if (isNaN(start) || isNaN(end) || start >= size || end >= size || start > end) {\n      res.status(416).setHeader('Content-Range', `bytes */${size}`).end();\n      return;\n    }\n    const chunk = mp3Buffer.slice(start, end + 1);\n    res.status(206);\n    res.setHeader('Content-Type', 'audio/mpeg');\n    res.setHeader('Content-Disposition', `inline; filename=\"${filename}\"`);\n    res.setHeader('Content-Range', `bytes ${start}-${end}/${size}`);\n    res.setHeader('Content-Length', String(chunk.length));\n    res.end(chunk);\n    return;\n  }\n\n  // full file\n  res.status(200);\n  res.setHeader('Content-Type', 'audio/mpeg');\n  res.setHeader('Content-Disposition', `inline; filename=\"${filename}\"`);\n  res.setHeader('Content-Length', String(size));\n  res.end(mp3Buffer);\n}\n\n// ElevenLabs API function\nasync function elevenTTS(payload) {\n  const { text, voice_id, model_id, voice_settings } = payload;\n  const r = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voice_id}`, {\n    method: \"POST\",\n    headers: {\n      \"xi-api-key\": process.env.ELEVEN_API_KEY,\n      \"accept\": \"audio/mpeg\",\n      \"content-type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      text,\n      model_id,\n      voice_settings,\n    }),\n  });\n\n  if (!r.ok) {\n    const msg = await r.text();\n    throw new Error(`ElevenLabs error: ${msg}`);\n  }\n\n  const arrayBuffer = await r.arrayBuffer();\n  return Buffer.from(arrayBuffer);\n}\n\n// ---- unified GET /tts & GET /tts.mp3 ----\napp.get(['/tts', '/tts.mp3'], async (req, res) => {\n  try {\n    const text = (req.query.text || '').toString();\n    if (!text.trim()) return res.status(400).send('No text provided');\n\n    const voice_id = (req.query.voice || DEFAULT_VOICE).toString();\n    const model_id = (req.query.model || DEFAULT_MODEL).toString();\n\n    const payload = {\n      text,\n      voice_id,\n      model_id,\n      voice_settings: {\n        stability: Number(req.query.stability ?? 0.4),\n        similarity_boost: Number(req.query.similarity ?? 0.85),\n      },\n    };\n\n    const key = cacheKey(payload);\n    let mp3 = cacheGet(key);\n    if (!mp3) {\n      mp3 = await elevenTTS(payload);   // your existing function\n      cacheSet(key, mp3);\n    }\n\n    // NOTE filename hint helps some browsers\n    sendMp3Buffer(req, res, mp3, 'tts.mp3');\n  } catch (e) {\n    res.status(500).send(String(e.message || e));\n  }\n});\n\napp.listen(PORT, () => console.log(`âœ… TTS server running on ${PORT}`));","size_bytes":3624}},"version":1}